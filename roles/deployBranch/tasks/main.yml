#
# Deploys / updates an already deployed branch
#
- name: Load config.json
  include_vars:
    file: "demos/{{ branch }}.json"
    name: branchConfig

- name: "{{ branch }} - Create tomcat context config"
  template:
    src: branch-context-config.xml.j2
    dest: "{{ config.tomcatFolder }}/conf/Catalina/localhost/scenarioo-{{ branch }}.xml"

- name: "{{ branch }} - Create docu artifacts folder"
  file: path="{{ config.scenariooDocuFolder }}/{{ branch }}" state=directory

# For each build downloaded we create a <buildNumber>.downloaded file in the scenarioo folder
# This way we know that we don't have to download the artifact a second time
# The following step checks for each docuArtifact if such a file exists and stores the result in stat_artifacts
- name: "{{ branch }} - Check status of downloaded artifacts"
  stat: path="{{ config.scenariooDocuFolder }}/{{ branch }}/{{ item.build }}.downloaded"
  register: stat_artifacts_cmd
  with_items: "{{ branchConfig.docuArtifacts }}"
- set_fact: stat_artifacts="{{ stat_artifacts_cmd.results }}"
# Datastructure of stat_artifacts:
#   stat_artifacts.stat.exists = true/false
#   stat_artifacts.item = { build: "", url: "", sha256: ""}

# Iterates over stat_artifacts
- name: "{{ branch }} - Download missing docu artifacts"
  get_url:
    url: "{{ artifact.item.url }}?circle-token={{ lookup('env', 'CIRLCE_TOKEN') }}"
    dest: "{{ config.scenariooDocuFolder }}/{{ branch }}/{{ artifact.item.build }}.zip"
  when: artifact.stat.exists == false
  with_items: "{{ stat_artifacts }}"
  loop_control:
      loop_var: artifact
  no_log: true  # Don't show CIRCLE_TOKEN in logs

- name: "{{ branch }} - Unarchive downloaded docu artifacts"
  unarchive:
    src: "{{ config.scenariooDocuFolder }}/{{ branch }}/{{ artifact.item.build }}.zip"
    dest: "{{ config.scenariooDocuFolder }}/{{ branch }}"
    remote_src: yes
  when: artifact.stat.exists == false
  with_items: "{{ stat_artifacts }}"
  loop_control:
      loop_var: artifact
  no_log: true  # Output is massive

- name: "{{ branch }} - Copy branchConfig"
  copy:
    src: "demos/{{ branch }}.json"
    dest: "{{ config.scenariooDocuFolder }}/{{ branch }}/branchConfig.json"

# Deleting builds that are present on disk but not in the branchConfig is cumbersome with ansible => Use a shellscript
- name: "{{ branch }} - Cleanup builds"
  script: "cleanupBuilds.sh {{ branch }} {{ config.scenariooDocuFolder }}"

- name: "{{ branch }} - Mark artifacts as downloaded"
  template:
    src: downloadedArtifact.j2
    dest: "{{ config.scenariooDocuFolder }}/{{ branch }}/{{ artifact.item.build }}.downloaded"
  when: artifact.stat.exists == false
  with_items: "{{ stat_artifacts }}"
  loop_control:
      loop_var: artifact

- name: "{{ branch }} - Delete downloaded docu artifacts ZIPs"
  file: path="{{ config.scenariooDocuFolder }}/{{ branch }}/{{ artifact.item.build }}.zip" state=absent
  when: artifact.stat.exists == false
  with_items: "{{ stat_artifacts }}"
  loop_control:
      loop_var: artifact

- name: "{{ branch }} - Ensure correct permissions"
  file: dest="{{ config.scenariooDocuFolder }}/{{ branch }}" owner=tomcat8 group=tomcat8 recurse=yes

- name: "{{ branch }} - Download & deploy war"
  get_url:
    url: "{{ branchConfig.warArtifact }}?circle-token={{ lookup('env', 'CIRLCE_TOKEN') }}"
    dest: "{{ config.tomcatFolder }}/webapps/scenarioo-{{ branch }}.war"
    sha256sum: "{{ branchConfig.warArtifactSha256 }}"     # Will only download if checksum changed
  no_log: true  # Don't show CIRCLE_TOKEN in logs

- name: "{{ branch }} - Wait for deployment"
  uri:
    url: "http://{{ config.scenariooHost }}/scenarioo-{{ branch }}"
    status_code: 200
  register: result
  until: result.status == 200
  delay: 3
  retries: 60
  when: lookup('env', 'ENVIRONMENT') != 'dev'   # Because would fail when using vagrant

- name: "{{ branch }} - Trigger reimport of builds"
  uri:
    url: "http://{{ config.scenariooHost }}/scenarioo-{{ branch }}/rest/builds/updateAndImport"
    status_code: 200,204
  when: lookup('env', 'ENVIRONMENT') != 'dev'   # Because would fail when using vagrant

